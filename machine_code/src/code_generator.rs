use intermediate_code::ioperand::IOperand;
use intermediate_code::{flow_graph::FlowGraph, icode::IntermediateCode};
use syntax::SymbolTable;

use crate::assembly::asm::Src;
use crate::emitter::CodeEmitter;
use crate::global_alloc::GlobalsAllocator;
use crate::output::{self, OutStream};
use intermediate_code::ioperator::IOperator::*;

pub struct CodeGenerator<'a> {
    out: OutStream,
    globals: GlobalsAllocator<'a>,
}

impl<'a> CodeGenerator<'a> {
    pub fn new(out: OutStream, table: &'a SymbolTable) -> Self {
        Self {
            globals: GlobalsAllocator::new(out.clone(), table),
            out,
        }
    }

    pub fn generate_header(&mut self) {
        self.out
            .borrow_mut()
            .write_all(b"# Output generated by the CoCo Compiler\n")
            .unwrap();
    }

    pub fn generate_global_decls(&mut self, table: &SymbolTable) {
        for (id, sym) in table.get_globals() {
            self.globals.insert(id, sym.return_type.into());
        }
    }

    pub fn generate_code(
        &'a self,
        table: &'a SymbolTable,
        icode: &IntermediateCode,
        graph: &FlowGraph,
    ) {
        let emitter = CodeEmitter::new(self.out.clone(), &self.globals, table);
        for (line, stmt) in icode {
            log::trace!("{}. {}", line, stmt);
            match stmt.operator {
                Func => emitter.emit_func(&stmt.label_id()),
                FuncCall => emitter.emit_call(&stmt.label_id(), &stmt.ret_target),
                Return => {
                    let src = match stmt.operand1 {
                        Some(IOperand::Immediate { value, .. }) => Src::Immediate(value),
                        None => Src::None,
                        _ => todo!("Implement non-immediate types of return values"),
                    };
                    emitter.emit_return(src);
                }
                _ => todo!("{}", stmt),
            }
        }
    }

    pub fn generate_trailer(&self) {
        self.write(&concat!(
            ".LC0:\n",
            "\t.string \"%d\"\n",
            "\t.globl readinteger\n",
            "readinteger:\n",
            "\tpushq\t%rbp\n",
            "\tmovq\t%rsp, %rbp\n",
            "\tsubq\t$16, %rsp\n",
            "\tleaq\t-12(%rbp), %rsi\n",
            "\tleaq\t.LC0(%rip), %rdi\n",
            "\tcall\tscanf\n",
            "\tmovl\t-12(%rbp), %eax\n",
            "\tmovq\t%rbp, %rsp\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC1:\n",
            "\t.string \"%d\\n\"\n",
            "\t.globl writeinteger\n",
            "writeinteger:\n",
            "\tpushq\t%rbp\n",
            "\tmovl\t%edi, %esi\n",
            "\tleaq\t.LC1(%rip), %rdi\n",
            "\tcall\tprintf\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC2:\n",
            "\t.string \"%u\"\n",
            "\t.globl readunsigned\n",
            "readunsigned:\n",
            "\tpushq\t%rbp\n",
            "\tmovq\t%rsp, %rbp\n",
            "\tsubq\t$16, %rsp\n",
            "\tleaq\t-12(%rbp), %rsi\n",
            "\tleaq\t.LC2(%rip), %rdi\n",
            "\tcall\tscanf\n",
            "\tmovl\t-12(%rbp), %eax\n",
            "\tmovq\t%rbp, %rsp\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC3:\n",
            "\t.string \"%u\\n\"\n",
            "\t.globl writeunsigned\n",
            "writeunsigned:\n",
            "\tpushq\t%rbp\n",
            "\tmovl\t%edi, %esi\n",
            "\tleaq\t.LC3(%rip), %rdi\n",
            "\tcall\tprintf\n",
            "\tpopq\t%rbp\n",
            "\tret\n"
        ));
    }

    fn write(&self, contents: &impl ToString) {
        output::write(self.out.clone(), contents);
    }
}
