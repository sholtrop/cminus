use intermediate_code::ioperand::IOperand;
use intermediate_code::{flow_graph::FlowGraph, icode::IntermediateCode};
use syntax::SymbolTable;

use crate::assembly::asm::Src;
use crate::emitter::CodeEmitter;
use crate::output::{self, OutStream};
use crate::reg_alloc::RegAlloc;
use intermediate_code::ioperator::IOperator::*;

pub struct CodeGenerator<'a> {
    out: OutStream,
    emitter: CodeEmitter<'a>,
    table: &'a SymbolTable,
    icode: &'a IntermediateCode,
    graph: &'a FlowGraph,
}

impl<'a> CodeGenerator<'a> {
    pub fn new(
        out: OutStream,
        table: &'a SymbolTable,
        graph: &'a FlowGraph,
        icode: &'a IntermediateCode,
    ) -> Self {
        let reg_alloc = RegAlloc::new(out.clone(), table, graph);
        let emitter = CodeEmitter::new(out.clone(), reg_alloc, table);
        Self {
            out,
            table,
            icode,
            graph,
            emitter,
        }
    }

    pub fn generate_header(&mut self) {
        self.write(&"# Output generated by the C-Minus Compiler\n");
    }

    pub fn generate_global_decls(&mut self) {
        self.emitter.emit_global_decls();
    }

    pub fn generate_code(&mut self) {
        for (line, stmt) in self.icode {
            log::trace!("{}. {}", line, stmt);
            self.emitter.set_line(line);
            match stmt.operator {
                Func => self.emitter.emit_func(&stmt.label_id()),
                FuncCall => self.emitter.emit_call(&stmt.label_id(), &stmt.ret_target),
                Return => {
                    self.emitter.emit_return(stmt.operand1.as_ref());
                }
                Add => {
                    let lhs = stmt.operand1.as_ref().unwrap();
                    let rhs = stmt.operand2.as_ref().unwrap();
                    let ret = stmt.ret_target.as_ref().unwrap().id();
                    self.emitter.emit_add(lhs, rhs, &ret);
                }
                _ => todo!("{}", stmt),
            }
        }
    }

    pub fn generate_trailer(&self) {
        self.write(&concat!(
            ".LC0:\n",
            "\t.string \"%d\"\n",
            "\t.globl readinteger\n",
            "readinteger:\n",
            "\tpushq\t%rbp\n",
            "\tmovq\t%rsp, %rbp\n",
            "\tsubq\t$16, %rsp\n",
            "\tleaq\t-12(%rbp), %rsi\n",
            "\tleaq\t.LC0(%rip), %rdi\n",
            "\tcall\tscanf\n",
            "\tmovl\t-12(%rbp), %eax\n",
            "\tmovq\t%rbp, %rsp\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC1:\n",
            "\t.string \"%d\\n\"\n",
            "\t.globl writeinteger\n",
            "writeinteger:\n",
            "\tpushq\t%rbp\n",
            "\tmovl\t%edi, %esi\n",
            "\tleaq\t.LC1(%rip), %rdi\n",
            "\tcall\tprintf\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC2:\n",
            "\t.string \"%u\"\n",
            "\t.globl readunsigned\n",
            "readunsigned:\n",
            "\tpushq\t%rbp\n",
            "\tmovq\t%rsp, %rbp\n",
            "\tsubq\t$16, %rsp\n",
            "\tleaq\t-12(%rbp), %rsi\n",
            "\tleaq\t.LC2(%rip), %rdi\n",
            "\tcall\tscanf\n",
            "\tmovl\t-12(%rbp), %eax\n",
            "\tmovq\t%rbp, %rsp\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC3:\n",
            "\t.string \"%u\\n\"\n",
            "\t.globl writeunsigned\n",
            "writeunsigned:\n",
            "\tpushq\t%rbp\n",
            "\tmovl\t%edi, %esi\n",
            "\tleaq\t.LC3(%rip), %rdi\n",
            "\tcall\tprintf\n",
            "\tpopq\t%rbp\n",
            "\tret\n"
        ));
    }

    fn write(&self, contents: &impl ToString) {
        output::write(self.out.clone(), contents);
    }
}
