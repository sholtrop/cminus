use intermediate_code::{flow_graph::FlowGraph, icode::IntermediateCode};
use syntax::SymbolTable;

use crate::emitter::CodeEmitter;
use crate::output::{self, OutStream};
use crate::reg_alloc::RegAlloc;
use intermediate_code::ioperator::IOperator::*;

pub struct CodeGenerator<'a> {
    out: OutStream,
    emitter: CodeEmitter<'a>,
    // table: &'a SymbolTable,
    icode: &'a IntermediateCode,
    // graph: &'a FlowGraph,
}

impl<'a> CodeGenerator<'a> {
    pub fn new(
        out: OutStream,
        table: &'a SymbolTable,
        graph: &'a FlowGraph,
        icode: &'a IntermediateCode,
    ) -> Self {
        let reg_alloc = RegAlloc::new(out.clone(), table, graph);
        let emitter = CodeEmitter::new(out.clone(), reg_alloc, table);
        Self {
            out,
            // table,
            icode,
            // graph,
            emitter,
        }
    }

    pub fn generate_header(&mut self) {
        self.write(&"# Output generated by the C-Minus Compiler\n");
    }

    pub fn generate_global_decls(&mut self) {
        self.emitter.emit_global_decls();
    }

    pub fn generate_code(&mut self) {
        for (line, stmt) in self.icode {
            log::trace!("{}. {}", line, stmt);
            self.emitter.set_line(line);
            match stmt.operator {
                Func => self.emitter.emit_func(&stmt.label_id()),
                FuncCall => self
                    .emitter
                    .emit_call(&stmt.label_id(), &stmt.ret_target.as_ref().map(|s| s.id())),
                Return => {
                    self.emitter.emit_return(stmt.operand1.as_ref());
                }
                Add => {
                    let (lhs, rhs, ret) = stmt.get_triple();
                    self.emitter.emit_add(lhs, rhs, &ret.id());
                }
                Sub => {
                    let (lhs, rhs, ret) = stmt.get_triple();
                    self.emitter.emit_sub(lhs, rhs, &ret.id());
                }
                Mul => {
                    let (lhs, rhs, ret) = stmt.get_triple();
                    self.emitter.emit_mul(lhs, rhs, &ret.id());
                }
                Coerce => {
                    let src = stmt.operand1.as_ref().unwrap();
                    let dest = stmt.ret_target.as_ref().unwrap().id();
                    self.emitter.emit_cast(src, &dest);
                }
                Assign => {
                    let src = stmt.operand2.as_ref().unwrap();
                    let dest = stmt.ret_target.as_ref().unwrap().id();
                    self.emitter.emit_assign(src, &dest);
                }
                Param => self.emitter.emit_param(stmt.operand1.as_ref().unwrap()),
                Je | Jne | Jz | Jnz | Ja | Jae | Jb | Jbe | Jg | Jge | Jl | Jle => {
                    let l_exp = stmt.operand1.as_ref().unwrap();
                    let r_exp = stmt.operand2.as_ref();
                    self.emitter.emit_conditional_jump(
                        &stmt.operator,
                        &stmt.ret_target.as_ref().unwrap().id(),
                        l_exp,
                        r_exp,
                    );
                }
                Goto => {
                    let ret = stmt.operand1.as_ref().unwrap();
                    self.emitter.emit_goto(&ret.id());
                }
                SetE | SetNE | SetA | SetAE | SetB | SetBE | SetG | SetGE | SetL | SetLE => {
                    let (l, r, ret) = stmt.get_triple();
                    let ret_id = ret.id();
                    self.emitter.emit_set(&stmt.operator, l, r, &ret_id);
                }
                Label => self.emitter.emit_label(&stmt.label_id()),
                Mod | Div => {
                    let (l, r, ret) = stmt.get_triple();
                    let ret_id = ret.id();
                    self.emitter.emit_div_mod(l, r, &ret_id, &stmt.operator);
                }
                _ => todo!("{}", stmt),
            }
        }
    }

    pub fn generate_trailer(&self) {
        self.write(&concat!(
            ".LC0:\n",
            "\t.string \"%d\"\n",
            "\t.globl readinteger\n",
            "readinteger:\n",
            "\tpushq\t%rbp\n",
            "\tmovq\t%rsp, %rbp\n",
            "\tsubq\t$16, %rsp\n",
            "\tleaq\t-12(%rbp), %rsi\n",
            "\tleaq\t.LC0(%rip), %rdi\n",
            "\tcall\tscanf\n",
            "\tmovl\t-12(%rbp), %eax\n",
            "\tmovq\t%rbp, %rsp\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC1:\n",
            "\t.string \"%d\\n\"\n",
            "\t.globl writeinteger\n",
            "writeinteger:\n",
            "\tpushq\t%rbp\n",
            "\tmovl\t%edi, %esi\n",
            "\tleaq\t.LC1(%rip), %rdi\n",
            "\tcall\tprintf\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC2:\n",
            "\t.string \"%u\"\n",
            "\t.globl readunsigned\n",
            "readunsigned:\n",
            "\tpushq\t%rbp\n",
            "\tmovq\t%rsp, %rbp\n",
            "\tsubq\t$16, %rsp\n",
            "\tleaq\t-12(%rbp), %rsi\n",
            "\tleaq\t.LC2(%rip), %rdi\n",
            "\tcall\tscanf\n",
            "\tmovl\t-12(%rbp), %eax\n",
            "\tmovq\t%rbp, %rsp\n",
            "\tpopq\t%rbp\n",
            "\tret\n",
            ".LC3:\n",
            "\t.string \"%u\\n\"\n",
            "\t.globl writeunsigned\n",
            "writeunsigned:\n",
            "\tpushq\t%rbp\n",
            "\tmovl\t%edi, %esi\n",
            "\tleaq\t.LC3(%rip), %rdi\n",
            "\tcall\tprintf\n",
            "\tpopq\t%rbp\n",
            "\tret\n"
        ));
    }

    fn write(&self, contents: &impl ToString) {
        output::write(self.out.clone(), contents);
    }
}
